(ns sm_async_api.hook.pusher
  {:clj-kondo/config  '{:linters {:unused-referred-var
                                  {:exclude {taoensso.timbre [log  trace  debug  info  warn  error  fatal  report
                                                              logf tracef debugf infof warnf errorf fatalf reportf
                                                              spy get-env]}}}}}
  (:require  [cheshire.core :as json]
             [org.httpkit.client :as http]
             [sm_async_api.dal.globals :as g]
             [taoensso.timbre :as timbre
              :refer [log  trace  debug  info  warn  error  fatal  report
                      logf tracef debugf infof warnf errorf fatalf reportf
                      spy get-env]]
             [taoensso.timbre.appenders.core :as appenders]
             [clojure.string :as str]
             [clojure.core.async
              :as a
              :refer [>! <! >!!  go  chan  close!
                     ; <!!  go-loop alts! alts!! timeout buffer sliding-buffer thread
                      ]]
             [sm_async_api.http_errors :as http-errors]
             [sm_async_api.hook.globals :refer [fetch-marker online-messangers]]))



(defn build-opts [{:keys [url method body id headers]}, thread]
  {:url url
   :method method
   :body body
   :thread thread
   :rec-id id
   :headers (json/parse-string headers)})


(defn pusher-factory
  "Return message pusher. 
   Depends on  async-pusher-enabled created  generates async or sync pusher.
   Pusher generated by async factory uses async http request pushing task to sm.
   Pusher factory requers the following parameters to create pusher:
    mode - one of :user-mode, :global-mode or async-mode 
    get-allowed - true or false, make sence for :user-mode only, allow user place get request 
    config -  global configuration, in most cases thes best choise is (config/get-config)
    workers -  workers configuration, in most cases thes best choise is (config/get-workers) 
   "
  [async-pusher-enabled]
  (timbre/with-merged-config
    {:appenders {:spit (appenders/spit-appender {:fname "log/pusher_conf.log"})}}
    (if (true? async-pusher-enabled)
      (fn [message thread write-channel-callback]
        (http/request (build-opts message thread) write-channel-callback))
      (fn [message thread]
        @(http/request (build-opts message thread))))))



(defn- write-channel-callback-factory [channel]
  (fn [resp]
    (>!! channel resp)))

(defn- exit-thread [^String id]
  (let [pusher-id ((str/split id #"\/" 2) 0)]
    (if (some? (@online-messangers pusher-id))
      (reportf  "Thread %s exited, %s threads left." id
                (((swap! online-messangers update-in [pusher-id :threads] dec)
                  pusher-id)  :threads))
      (error (AssertionError. (format "Thread %s not found in thread list: %s" pusher-id @online-messangers))))))

(defn message-sender-factory [async?]
  (let [delete-message (:delete @g/hook-action)
        reschedule-message (:reschedule @g/hook-action)]
    (fn [in out ^String id]
      (let [local-channel (when async? (chan))
            pusher (pusher-factory async?)
            write-channel-callback (when async? (write-channel-callback-factory local-channel))]
        (timbre/with-merged-config
          {:appenders {:println {:enabled? false}
                       :spit (appenders/spit-appender {:fname (str "log/" ((str/split id #"/" 2) 0) ".log")})}}
          (reportf "%s:Message sender configured for %s mode" id (if (nil? local-channel) "sync" "async"))
          (go
            (loop [input (<! in)]
              (if (string? input)
                (when (= input fetch-marker)
                  (>! out  fetch-marker) (recur  (<! in))) ; exit on any string exept "FETCH"
                (do (debug  id ":Send message:"  (:id input) "Attempt:" (:attempt input))
                    (let [{:keys [error status]}   (if async?
                                                     (do (pusher input id write-channel-callback)
                                                         (<! local-channel))
                                                     (pusher input id))]
                      (debug  id ":Send result for message "  (input :req_id) "  " status)
                      (if  error
                        (fatal "Failed, exception: error " error " in attempt to send " input)
                        (do  (if (or (= (:attempt input) 1)
                                     (= status http-errors/OK))
                               (delete-message (:id input))
                               (reschedule-message (:id input)))
                             (recur (<! in))))))))
            (exit-thread id)
            (when (some? local-channel) (close! local-channel))))))))